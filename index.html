<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Atypes, Btypes, and ctypes</title>

		<meta name="description" content="Atypes, Btypes, and ctypes">
		<meta name="author" content="Ben Timby">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
                
                <style type="text/css">
                .wrap {
                   width:900px;
                   margin:0 auto;
                }
                .left_col {
                   float:left;
                   width:450px;
                }
                .right_col {
                   float:right;
                   width:450px;
                }
                .lang {
                    text-align: left
                }
                </style>
        </head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Atypes, Btypes, and ctypes</h1>
					<h4>Introduction to using C in Python</h4>
					<p>
						<small>presented by <a href="http://ben.timby.com/">Ben Timby</a> / <a href="mailto:btimby@smartfile.com">btimby@smartfile.com</a></small>
					</p>

                                        <aside class="notes" data-markdown>
                                        * Hi I am Ben Timby.
                                        * I live in Indiana, but was born in Ohio, it feels good to be back!
                                        * I work for SmartFile, we develop a Python web application. We have the opportunity to use a LOT of open source code.
                                        * For my day job I have utilized ctypes (the topic) for a variety of tasks.
                                        * I have also used SWIG.
                                        * I have manually written wrappers for C libraries using the CPython API.
                                        * I perfer ctypes!
                                        </aside>
				</section>

				<section>
					<h2>What?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <img src="/img/strange-hammer.jpg"/>
                                            </div>
                                            <div class="right_col">
                                                <span>
                                                    <p>Ctypes is a tool you don't need every day, but it is indispensible when you do need it.</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Use ctypes to utilize C libraries from Python.</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Call existing libraries or write your own.</p>
                                                </span>
                                                <!--<ul>
                                                    <li class="fragment">ctypes is a tool you don't need every day.</li>
                                                    <li class="fragment">Indispensible when you do need it.</li>
                                                    <li class="fragment">Integrate Python &amp; C.</li>
                                                    <li class="fragment">Use existing C libraries.</li>
                                                    <li class="fragment">Or write your own.</li>
                                                </ul>-->
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * ctypes is a powerful tool that you should know how to use.
                                        * ctypes like Python is simple for simple tasks, but can scale up to more difficult tasks.
                                        * ctypes is an FFI (Foreign Function Interface) allowing Python and C code to interact.
                                        * As the name implies, ctypes is mostly concerned with translating between Python types and C types.
                                        * It also handles C calling conventions.
                                        * You can call C functions. C functions can also call Python functions (callbacks).
                                        </aside>
				</section>

				<section>
					<h2>Who?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <span class="fragment">
                                                    <h3>YOU!</h3>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Ctypes is already installed (Python 2.5+).</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Stdlib modules multiprocessing and uuid use ctypes.</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Ctypes is simple for Python programmers to learn.</p>
                                                </span>

                                                <!--<ul>
                                                    <li class="fragment">You!</li>
                                                    <li class="fragment">ctypes is already installed (Python 2.5+).</li>
                                                    <li class="fragment">Stdlib modules multiprocessing and uuid use ctypes.</li>
                                                    <li class="fragment">ctypes is simple for Python programmers to learn.</li>
                                                </ul>-->
                                            </div>
                                            <div class="right_col">
                                                <img src="/img/who-md.png"/>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Hopefully after today, you will run into a problem that ctypes can help you overcome.
                                        * I want to give you enough information so that you can get started
                                        </aside>
				</section>

                                <section>
                                    <h2>Why?</h2>

                                    <div class="wrap">
                                        <div class="left_col">
                                                <span class="fragment">
                                                    <p>There are thousands of C libraries for almost every purpose.</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Why not use them?</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Performance benefits.</p>
                                                </span>
                                                <span class="fragment">
                                                    <hr/>
                                                    <p>Interface with legacy systems &amp; code.</p>
                                                </span>
                                            <!--<ul>
                                                <li class="fragment">Don't reinvent the wheel.</li>
                                                <li class="fragment">Execution speed.</li>
                                                <li class="fragment">Legacy systems / code.</li>
                                            </ul>-->
                                        </div>
                                        <div class="right_col">
                                            <img src="/img/shoe-wheel.jpg"/>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * Sometimes through profiling you identify performance trouble spots.
                                    * Optimized algorithms are already implemented in C.
                                    * ctypes can allow you to call that C algorithm.
                                    * C is an old programming language.
                                    * There are thousands of mature C libraries.
                                    * You may need to integrate with a legacy system.
                                    * If the legacy system utilizes a library (it should!) you can load and call it.
                                    * Bring old programs to the Web (2.0) era!
                                    </aside>
                                </section>

                                <section>
                                    <h2>Why Not?</h2>
                                    <h4>ctypes is not always the right choice</h4>

                                    <div class="wrap">
                                        <div class="left_col">
                                                <span>
                                                    <p>There are many competing tools.</p>
                                                </span>
                                                <span class="fragment" data-fragment-index="2">
                                                    <hr/>
                                                    <p>Why would I choose ctypes?</p>
                                                </span>
                                            <!--<ul>
                                                <li>There are many options that do similar things.</li>
                                                <li class="fragment" data-fragment-index="2">Why choose ctypes over these options?</li>
                                            </ul>-->
                                        </div>
                                        <div class="right_col">
                                            <ul class="fragment" data-fragment-index="1">
                                                <li>Pyrex</li>
                                                <li>SWIG</li>
                                                <li>Cython</li>
                                                <li>psyco</li>
                                                <li>weave</li>
                                            </ul>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * ctypes is not the only game in town.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Why SWIG instead of ctypes?</h2>
                                    
                                    <div class="wrap">
                                        <div class="left_col">
                                            <h3>Pros</h3>
                                            <ul>
                                                <li>Multiply your effort by targeting many languages at once.</li>
                                                <li>Port existing wrapper from another language.</li>
                                            </ul>
                                        </div>
                                        <div class="right_col">
                                            <span class="fragment"><h3>Cons</h3>
                                            <ul>
                                                <li>Generated C code is ugly.</li>
                                                <li>A lot of work if you only need to support Python.</li>
                                                <li>Specialized syntax for defining interface.</li>
                                            </ul></span>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * SWIG is the clear choice if you need to generate wrappers for more than just Python.
                                    * You can leverage other people's work by converting an existing SWIG wrapper to Python.
                                    * The C code that SWIG generates is not fit for human consumption (could be hard to debug).
                                    * Thankfully it is usually short and repetitive.
                                    * If you are only supporting Python, it is like using a sledgehammer.
                                    * SWIG uses a C-like syntax for defining the C library's interface.
                                    * Yet there are many SWIG specific concepts you must learn.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Why Cython instead of ctypes?</h2>
                                    
                                    <div class="wrap">
                                        <div class="left_col">
                                            <h3>Pros</h3>
                                            <ul>
                                                <li>Cython can execute faster than ctypes.</li>
                                                <li>Not only C code but also Python code.</li>
                                            </ul>
                                        </div>
                                        <div class="right_col">
                                            <span class="fragment"><h3>Cons</h3>
                                            <ul>
                                                <li>Specialized Python-esque syntax.</li>
                                                <li>Requires compilation.</li>
                                            </ul></span>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * If execution speed is your goal then Cython may be the right choice.
                                    * Cython translates Python code to C code then compiles it.
                                    * Once Python is compiled, calling C libraries is trivial.
                                    * Cython uses a Python-like syntax that will take some getting used to.
                                    * Cython compilation to achieve what ctypes can without.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Why ctypes instead SWIG/Cython?</h2>
                                    
                                    <div class="wrap">
                                        <div class="left_col">
                                            <h3>Pros</h3>
                                            <ul>
                                                <li>Ease of use.</li>
                                                <li>Rapid development.</li>
                                            </ul>
                                        </div>
                                        <div class="right_col">
                                            <span class="fragment"><h3>Cons</h3>
                                            <ul>
                                                <li>
                                                    Execution speed.
                                                    <ul>
                                                        <li>FFI incurs overhead for every function call.</li>
                                                        <li>Pre-compiled boundaries are faster.</li>
                                                    </ul>
                                                </li>
                                                <li>Python only.</li>
                                            </ul></span>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * You can start using ctypes today.
                                    * A simple task is trivial using ctypes.
                                    * The border between Python and C requires a lot of processing.
                                    * Each function call incurs overhead.
                                    * To mitigate this penalty, move tight loops to C, write your own intermediate library, and call that.
                                    * ctypes only addresses Python.
                                    * However, even if you plan on using SWIG or Cython, ctypes may be a great way to plan / prototype.
                                    </aside>
                                </section>

                                <section>
                                    <h2>How?</h2>
                                    <h4>Destroy problems with ctypes!</h4>

                                    <div class="wrap">
                                        <div class="left_col">
                                            <ul>
                                                <li class="fragment">Research your target.</li>
                                                <li class="fragment">Skirmish.</li>
                                                <li class="fragment">Tactics.</li>
                                                <li class="fragment">Udder devastation!</li>
                                            </ul>
                                        </div>
                                        <div class="right_col">
                                            <img src="/img/larry.png" bgcolor="white"/>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * Research your target.
                                        * Find example projects using it.
                                        * Read documentation.
                                        * Write a simple C program that uses the library.
                                    * Skirmish.
                                        * Try loading the library using ctypes.
                                        * Initialize the library.
                                        * Finalize the library.
                                    * Tactics.
                                        * Some common things you will need to do using ctypes.
                                    * Udder devastation!
                                        * Implement your C wrapper.
                                        * Unit tests start passing.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Research your target:</h2>
                                    <h4>Librsync</h4>

                                    <div class="wrap">
                                        <div class="left_col">
                                            <div class="lang"><strong>Fedora</strong></div>
                                            <pre><code class="sh" data-trim>
$ sudo yum install librsync
$ sudo yum install librsync-devel
                                            </code></pre>
                                        </div>
                                        <div class="right_col">
                                            <ul>
                                                <li class="fragment">Mature library.</li>
                                                <li class="fragment">Excellent documentation.</li>
                                                <li class="fragment">Tons of examples.</li>
                                                <li class="fragment">Very fast.</li>
                                                <li class="fragment">Found unsuitable wrappers.</li>
                                            </ul>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * My intention is to give a quick tutorial from start to finish.
                                    * Not neccesarily teach about librsync specifically.
                                    * Librsync is an excellent use-case for ctypes.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Skirmish</h2>

                                    <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * Import ctypes.
                                    * ctypes.util contains find_library, which searches for installed libraries by name.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Skirmish</h2>

                                    <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))

if __name__ == '__main__':
# rs_job_t* rs_sig_begin (size_t new_block_len, size_t strong_sum_len)
j = _rsync.rs_sig_begin(2048, 8)
# rs_result rs_job_free (rs_job_t *)
r = _rsync.rs_job_free(j)
print('Return code: %s' % r)
                                    </code></pre>
                                    <h4 class="fragment"><font color="red">UH-OH!</font></h4>

                                    <aside class="notes" data-markdown>
                                    * I added the C function definitions as comments.
                                    * ctypes automagically converts the types for you!
                                    * However, there is a problem with this code!
                                    </aside>
                                </section>

                                <section>
                                    <h2>Skirmish</h2>

                                    <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))

# rs_job_t *rs_sig_begin(size_t new_block_len, size_t strong_sum_len);
_librsync.rs_sig_begin.restype = ctypes.c_void_p
_librsync.rs_sig_begin.argtypes = (ctypes.c_size_t, ctypes.c_size_t, )

# rs_result rs_job_free(rs_job_t *);
_librsync.rs_job_free.restype = ctypes.c_int
_librsync.rs_job_free.argtypes = (ctypes.c_void_p, )

if __name__ == '__main__':
j = _rsync.rs_sig_begin(2048, 8)
r = _rsync.rs_job_free(j)
print('Return code: %s' % r)
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * You need to define the function prototypes you plan to use.
                                    * Assign types to the parameters and return value.
                                    * This code would likely work as-is.
                                    * As soon as you try to use it in a complex program it would likely fail.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Defining constants</h4>

                                    <div class="wrap">
                                        <div class="left_col">
                                            <div class="lang"><strong>C (header)</strong></div>
                                            <pre><code class="c" data-trim>
typedef enum {
    RS_DONE =           0,
    RS_BLOCKED =        1,
    ...
} rs_result;

#define RS_DEFAULT_STRONG_LEN 8
#define RS_DEFAULT_BLOCK_LEN 2048
                                            </code></pre>
                                        </div>
                                        <div class="right_col">
                                            <div class="lang"><strong>Python</strong></div>
                                            <pre><code class="python" data-trim>
RS_DONE = 0
RS_BLOCKED = 1

RS_DEFAULT_STRONG_LEN = 8
RS_DEFAULT_BLOCK_LEN = 2048
                                            </code></pre>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * Most C libraries will use constants.
                                    * You will need to redefine them in Python.
                                    * You might pass them as parameters, or test return values against them.
                                    </aside>
                                </section>


                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Defining structures</h4>

                                    <div class="wrap">
                                        <div class="left_col">
                                            <div class="lang"><strong>C (header)</strong></div>
                                            <pre><code class="c" data-trim>
struct rs_buffers_s {
    char *next_in;
    size_t avail_in;
    int eof_in;

    char *next_out;
    size_t avail_out;
};
                                            </code></pre>
                                        </div>
                                        <div class="right_col">
                                            <div class="lang"><strong>Python</strong></div>
                                            <pre><code class="python" data-trim>
class Buffer(ctypes.Structure):
    _fields_ = [
        ('next_in',
            ctypes.c_char_p),
        ('avail_in',
            ctypes.c_size_t),
        ('eof_in',
            ctypes.c_int),

        ('next_out',
            ctypes.c_char_p),
        ('avail_out',
            ctypes.c_size_t),
    ]
                                            </code></pre>
                                        </div>
                                    </div>

                                    <aside class="notes" data-markdown>
                                    * Most C libraries will use structures.
                                    * Structs are data types packed together in memory.
                                    * ctypes allows you to define these as classes.
                                    * You can access the members as attributes.
                                    * Structure is by default *native* byte order.
                                    * LittleEndianStructure and BigEndianStructure allow you to specify byte order.
                                    
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Defining callbacks</h4>

                                    <div class="lang"><strong>C (header)</strong></div>
                                    <pre><code class="c" data-trim>
typedef rs_result rs_copy_cb(void *opaque, rs_long_t pos,
                             size_t *len, void **buf);
                                    </code></pre>

                                    <div class="lang"><strong>Python</strong></div>
                                    <pre><code class="python" data-trim>
callback = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int, ctypes.c_size_t,
                            ctypes.POINTER(Buffer))
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * Some C libraries use callbacks.
                                    * You pass a pointer to a function and the library calls it.
                                    * Callbacks are commonly used as error handlers, events, I/O.
                                    * ctypes allows you to create a decorator that declares your callback function prototype.
                                    * You can then decorate a Python function with it.
                                    * You can pass that function to a C library.
                                    * The C library can then make calls into your Python function.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Using callbacks</h4>

                                    <div class="lang"><strong>Python</strong></div>
                                    <pre><code class="python" data-trim>
@callback
def read_cb(ign, pos, length, buff):
    f.seek(pos)
    block = f.read(length)
    buff.next_in = ctypes.c_char_p(block)
    buff.avail_in = ctypes.c_size_t(len(block))
    return RS_DONE

# Second parameter is a state value to pass to our function, which
# is not used.
job = _librsync.rs_patch_begin(read_cb, None)
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * Decorate the Python function using the `CFUNCTYPE` decorator.
                                    * Pass it to the library as prescribed.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Error Handling</h4>

                                    <div class="lang"><strong>Python</strong></div>
                                    <pre><code class="python" data-trim>
class LibrsyncError(Exception):
    def __init__(self, r):
        super(LibrsyncError, self).__init__(
              _librsync.rs_strerror(ctypes.c_int(r)))

r = _librsync.rs_job_iter(job, ctypes.byref(buff))
if r not in (RS_DONE, RS_BLOCKED):
    raise LibrsyncError(r)
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * Errors are generally denoted by return values.
                                    * 0 is (almost) universally success.
                                    * Most libraries can convert a return code to an error message.
                                    * Lends itself well to converting return codes to Python Exceptions.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Error Handling</h4>

                                    <div class="lang"><strong>Python</strong></div>
                                    <pre><code class="python" data-trim>
class LibrsyncError(Exception):
    def __init__(self, r):
        super(LibrsyncError, self).__init__(
              _librsync.rs_strerror(ctypes.c_int(r)))

def errcheck(*success):
    def check_raise(r, f, args):
        if r not in success:
            raise LibrsyncError(r)
        return r
    return check_raise

_librsync.rs_job_iter.errcheck = errcheck(RS_DONE, RS_BLOCKED)

_librsync.rs_job_iter(job, ctypes.byref(buff))
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * Checking for errors is repetitive, ctypes allows you to automate it.
                                    * Different functions may have different acceptable return values.
                                    * The above allows you to easily customize this by function.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Error Handling</h4>

                                    <div class="lang"><strong>Python</strong></div>
                                    <pre><code class="python" data-trim>
>>> import ctypes, ctypes.util
>>> _c = ctypes.CDLL(ctypes.util.find_library('c'), use_errno=True)
>>> _c.strerror.argtypes = [ctypes.c_int]
>>> _c.strerror.restype = ctypes.c_char_p
>>> _c.open('.', 1)
-1
>>> ctypes.get_errno()
21
>>> _c.perror('open')
open: Is a directory
21
>>> _c.strerror(ctypes.get_errno())
'Is a directory'

                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * Some libraries (libc) set the global errno to indicate errors.
                                    * Ctypes handles this in a thread-safe manner.
                                    * Notably Windows use a similar strategy (GetLastError()).
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Freeing memory</h4>
                                    <pre><code class="python" data-trim>
sig = ctypes.c_void_p()
try:
    job = _librsync.rs_loadsig_begin(byref(sig))
    try:
        _execute(job, s)
    finally:
        _librsync.rs_job_free(job)
    r = _librsync.rs_build_hash_table(sig)
    if r != RS_DONE:
        raise LibrsyncException(r)
...
finally:
    _librsync.rs_free_sumset(sig)
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * No GC in C!
                                    * Allocations made by ctypes use reference counting.
                                    * Allocations made by C functions do NOT!
                                    * The code above makes explicit and implicit allocations.
                                    * Explicit
                                        * You must be dilligent about freeing what you allocate.
                                        * In this example, job is allocated implicitly by calling `rs_loadsig_begin()`.
                                        * It must be freed when we are done with it!
                                    * Implicit.
                                        * You must pay attention to allocations made by the library.
                                        * In this example, sig is a pointer we allocate, and pass by reference.
                                        * The libary performs an allocation and fills the pointer to it.
                                        * We must free the allocated structure when it is no longer needed.
                                    * Finally is your friend!
                                    * When an error occurs and you raise an exception, memory must still be freed.
                                    </aside>
                                </section>

                                <section>
                                    <h2>Tactics</h2>
                                    <h4>Using Strings &amp; Buffers</h4>
                                    <pre><code class="python" data-trim>
o = StringIO()
out = ctypes.create_string_buffer(RS_JOB_BLOCKSIZE)

while True:
    buff, block = Buffer(), f.read(RS_JOB_BLOCKSIZE)
    # provide the data block via input buffer.
    buff.next_in = ctypes.c_char_p(block)
    buff.avail_in = ctypes.c_size_t(len(block))
    buff.eof_in = ctypes.c_int(not block)
    # Set up our buffer for output.
    buff.next_out = ctypes.cast(out, ctypes.c_char_p)
    buff.avail_out = ctypes.c_size_t(RS_JOB_BLOCKSIZE)
    r = _librsync.rs_job_iter(job, ctypes.byref(buff))
    o.write(out.raw[:RS_JOB_BLOCKSIZE - buff.avail_out])
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * In C strings are char arrays.
                                    * They are represented by a pointer to the head.
                                    * You must be aware of their length.
                                    * You usually must inform the C library of the length.
                                    * This is done to avoid overruns.
                                    * Here we use strings in two capacities.
                                    * Input
                                        * The string `block` is handled by getting `c_char_p`, the pointer to the string buffer.
                                    * Output
                                        * `out` is a string buffer, which can be accessed by Python via `raw`.
                                        * `buff.avail_out` informs librsync how large our allocated buffer is.
                                        * Upon return, librsync tells us how much data to expect via `buff.avail_out`.
                                    </aside>
                                </section>

                                <section>
                                    <h2>BOOM!</h2>
                                    <h4>When things don't go as planned</h4>

                                    <div class="wrap">
                                        <div class="left_col">
                                            <div class="lang"><strong>Fedora</strong></div>
                                            <pre><code class="sh" data-trim>
$ sudo yum install gdb
$ sudo debuginfo-install python
$ sudo debuginfo-install librsync
                                            </code></pre>
                                        </div>
                                        <div class="right_col">
                                            <ul>
                                                <li class="fragment">GDB is great for debugging Python &amp; ctypes.</li>
                                                <li class="fragment">Make sure you have the symbols installed for Python and the target.</li>
                                            </ul>
                                        </div>
                                    </div>


                                    <aside class="notes" data-markdown>
                                    * The Python ctypes module docs are excellent.
                                    </aside>
                                </section>

                                <section>
                                    <h2>BOOM!</h2>
                                    <h4>Debugging with GDB</h4>

                                    <div class="lang"><strong>Python (segfault.py)</strong></div>
                                    <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))

_librsync.rs_job_free(0)
                                    </code></pre>

                                    <div class="lang"><strong>GDB</strong></div>
                                    <pre><code class="sh" data-trim>
$ gdb -ex r --args python segfault.py
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * This is a very contrived failing program.
                                    * NULL pointer, which will cause a segmentation fault.
                                    * Your problem will likely be much less obvious.
                                    * But debugging will be the same.
                                    </aside>
                                </section>

                                <section>
                                    <h2>BOOM!</h2>
                                    <h4>Debugging with GDB</h4>

                                    <div class="lang"><strong>Python (segfault.py)</strong></div>
                                    <pre><code class="gdb" data-trim>
Program received signal SIGSEGV, Segmentation fault.
rs_job_free (job=0x0) at job.c:87
87          if (job->scoop_buf)
(gdb) bt
#0  rs_job_free (job=0x0) at job.c:87
#1  0x0000003f4b605ed8 in ffi_call_unix64 () from /lib64/libffi.so.5
#2  0x0000003f4b6058e0 in ffi_call () from /lib64/libffi.so.5
#3  0x00007ffff0b02bf0 in _call_function_pointer (argcount=1, resmem=0x7fffffffd2f0, restype=<optimized out>, atypes=<optimized out>, 
    avalues=0x7fffffffd2d0, pProc=0x3f48e04a80 <rs_job_free>, flags=4353)
    at /usr/src/debug/Python-2.7.3/Modules/_ctypes/callproc.c:827
                                    </code></pre>

                                    <aside class="notes" data-markdown>
                                    * There are SEVEN calls in the stack between Python and `rs_job_free()`!
                                    </aside>
                                </section>

                                <section>
                                    <h2>More information</h2>

                                    <a href="http://docs.python.org/2/library/ctypes.html">http://docs.python.org/2/library/ctypes.html</a>

                                    <aside class="notes" data-markdown>
                                    * The Python ctypes module docs are excellent.
                                    </aside>
                                </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
