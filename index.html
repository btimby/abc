<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Atypes, Btypes, and Ctypes</title>

		<meta name="description" content="Atypes, Btypes, and Ctypes">
		<meta name="author" content="Ben Timby">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
                
                <style type="text/css">
                .wrap {
                   width:900px;
                   margin:0 auto;
                }
                .left_col {
                   float:left;
                   width:450px;
                }
                .right_col {
                   float:right;
                   width:450px;
                }
                .lang {
                    text-align: left
                }
                </style>
        </head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Atypes, Btypes, and Ctypes</h1>
					<h3>Introduction to using C in Python</h3>
					<p>
						<small>presented by <a href="http://ben.timby.com/">Ben Timby</a> / <a href="mailto:btimby@smartfile.com">btimby@smartfile.com</a></small>
					</p>

                                        <aside class="notes" data-markdown>
                                        * Hi I am Ben Timby.
                                        * I live in Indiana, but was born in Ohio, it feels good to be back!
                                        * I work for SmartFile, we develop a Python web application. We have the opportunity to use a LOT of open source code.
                                        * For my day job I have utilized Ctypes (the topic) for a variety of tasks.
                                        * I have also used SWIG.
                                        * I have manually written wrappers for C libraries using the CPython API.
                                        * I perfer Ctypes!
                                        </aside>
				</section>

				<section>
					<h2>What?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <img src="/img/strange-hammer.jpg"/>
                                            </div>
                                            <div class="right_col">
                                                <ul>
                                                    <li>Ctypes is a tool you don't need every day.</li>
                                                    <li>Indispensible when you do need it.</li>
                                                    <li>Extend Python using C.</li>
                                                    <li>Use existing C libraries.</li>
                                                    <li>Or write your own.</li>
                                                </ul>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Ctypes is a powerful tool that you should know how to use.
                                        * Ctypes like Python is simple for simple tasks, but can scale up to more difficult tasks.
                                        * Ctypes is an FFI (Foreign Function Interface) allowing Python and C code to interact.
                                        * As the name implies, Ctypes is mostly concerned with translating between Python types and C types.
                                        * It also handles C calling conventions.
                                        * You can call C functions. C functions can also call Python functions (callbacks).
                                        </aside>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<h2>Who?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <ul>
                                                    <li>You! Ctypes is already installed (2.5 and up).</li>
                                                    <li>Stdlib modules multiprocessing and uuid use ctypes.</li>
                                                    <li>Ctypes is simple for Python programmers to learn.</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <img src="/img/who-md.png"/>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Hopefully after today, you will run into a problem that Ctypes can help you overcome.
                                        * I want to give you enough information so that you can get started
                                        </aside>
				</section>

				<section>
                                    <section>
					<h2>Why?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <ul>
                                                    <li>Execution speed.</li>
                                                    <li>Don't reinvent the wheel.</li>
                                                    <li>Legacy systems / code.</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <img src="/img/who-md.png"/>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Sometimes through profiling you identify performance trouble spots.
                                        * Optimized algorithms are already implemented in C.
                                        * Ctypes can allow you to call that C algorithm.
                                        * C is an old programming language.
                                        * There are thousands of mature C libraries.
                                        * You may need to integrate with a legacy system.
                                        * If the legacy system utilizes a library (it should!) you can load and call it.
                                        * Bring old programs to the Web (2.0) era!
                                        </aside>
                                    </section>

                                    <section>
					<h2>Why Not?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <ul>
                                                    <li>There are many options that do similar things.</li>
                                                    <li>Why choose Ctypes over these options?</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <ul>
                                                    <li>Ctypes</li>
                                                    <li>Pyrex</li>
                                                    <li>SWIG</li>
                                                    <li>Cython</li>
                                                    <li>psyco</li>
                                                    <li>weave</li>
                                                </ul>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Ctypes is not the only game in town.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Why SWIG instead of Ctypes?</h2>
                                        
                                        <div class="wrap">
                                            <div class="left_col">
                                                <h3>Pros</h3>
                                                <ul>
                                                    <li>Multiply your effort by targeting many languages at once.</li>
                                                    <li>Port existing wrapper from another language.</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <h3>Cons</h3>
                                                <ul>
                                                    <li>Generated C code is ugly.</li>
                                                    <li>A lot of work if you only need to support Python.</li>
                                                    <li>Specialized syntax for defining interface.</li>
                                                </ul>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * SWIG is the clear choice if you need to generate wrappers for more than just Python.
                                        * You can leverage other people's work by converting an existing SWIG wrapper to Python.
                                        * The C code that SWIG generates is not fit for human consumption (could be hard to debug).
                                        * Thankfully it is usually short and repetitive.
                                        * If you are only supporting Python, it is like using a sledgehammer.
                                        * SWIG uses a C-like syntax for defining the C library's interface.
                                        * Yet there are many SWIG specific concepts you must learn.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Why Cython instead of Ctypes?</h2>
                                        
                                        <div class="wrap">
                                            <div class="left_col">
                                                <h3>Pros</h3>
                                                <ul>
                                                    <li>Cython can execute faster than Ctypes.</li>
                                                    <li>Not only C code but also Python code.</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <h3>Cons</h3>
                                                <ul>
                                                    <li>Specialized Python-esque syntax.</li>
                                                    <li>Requires compilation.</li>
                                                </ul>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * If execution speed is your goal then Cython may be the right choice.
                                        * Cython translates Python code to C code then compiles it.
                                        * Once Python is compiled, calling C libraries is trivial.
                                        * Cython uses a Python-like syntax that will take some getting used to.
                                        * Cython compilation to achieve what Ctypes can without.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Why Ctypes instead SWIG/Cython?</h2>
                                        
                                        <div class="wrap">
                                            <div class="left_col">
                                                <h3>Pros</h3>
                                                <ul>
                                                    <li>Ease of use.</li>
                                                    <li>Rapid development.</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <h3>Cons</h3>
                                                <ul>
                                                    <li>
                                                        Execution speed.
                                                        <ul>
                                                            <li>FFI incurs overhead for every function call.</li>
                                                            <li>Pre-compiled boundaries are faster.</li>
                                                        </ul>
                                                    </li>
                                                    <li>Python only.</li>
                                                </ul>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * You can start using Ctypes today.
                                        * A simple task is trivial using Ctypes.
                                        * The border between Python and C requires a lot of processing.
                                        * Each function call incurs overhead.
                                        * To mitigate this penalty, move tight loops to C, write your own intermediate library, and call that.
                                        * Ctypes only addresses Python.
                                        * However, even if you plan on using SWIG or Cython, Ctypes may be a great way to plan / prototype.
                                        </aside>
                                    </section>
                                </section>

				<section>
                                    <section>
                                        <h2>How?</h2>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <ul>
                                                    <li>Research your target.</li>
                                                    <li>Dip your toe in.</li>
                                                    <li>Plan your attack.</li>
                                                    <li>Write unit tests.</li>
                                                    <li>Blitzkrieg!</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <img src="/img/target.png"/>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * want to give you a bit of 
                                        * Research your target.
                                            * Find example projects using it.
                                            * Read documentation.
                                            * Write a simple C program that uses the library.
                                        * Dip your toe in.
                                            * Try loading the library using Ctypes.
                                            * Initialize the library.
                                            * Finalize the library.
                                        * Plan your attack.
                                            * Learn how the library operates.
                                            * Learn how to handle errors.
                                            * Determine which functions you plan to use.
                                        * Write unit tests.
                                            * Write a unit test for each function you will use.
                                        * Blitzkreig!
                                            * Implement your C wrapper.
                                            * Unit tests start passing.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Research your target</h2>
                                        <h3>Librsync</h3>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <ul>
                                                    <li>Mature library.</li>
                                                    <li>Excellent documentation.</li>
                                                    <li>Tons of examples.</li>
                                                    <li>Very fast.</li>
                                                    <li>Found unsuitable wrappers.</li>
                                                </ul>
                                            </div>
                                            <div class="right_col">
                                                <pre><code class="python" data-trim>
$ yum install librsync
$ yum install librsync-devel
                                                </code></pre>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * My intention is to give a quick tutorial from start to finish.
                                        * Not neccesarily teach about librsync specifically.
                                        * Librsync is an excellent use-case for Ctypes.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Dip your toe in</h2>

                                        <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * Import ctypes.
                                        * ctypes.util contains find_library, which searches for installed libraries by name.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Dip your toe in</h2>

                                        <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))

if __name__ == '__main__':
    # rs_job_t* rs_sig_begin (size_t new_block_len, size_t strong_sum_len)
    j = _rsync.rs_sig_begin(1024, 8)
    # rs_result rs_job_free (rs_job_t *)
    r = _rsync.rs_job_free(j)
    print('Return code: %s' % r)
                                        </code></pre>
                                        <h3><font color="red">UH-OH!</font></h3>

                                        <aside class="notes" data-markdown>
                                        * I added the C function definitions as comments.
                                        * Ctypes automagically converts the types for you!
                                        * However, there is a problem with this code!
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>WHEW!</h2>

                                        <pre><code class="python" data-trim>
import ctypes
import ctypes.util

_librsync = ctypes.cdll.LoadLibrary(ctypes.util.find_library('rsync'))

# rs_job_t *rs_sig_begin(size_t new_block_len, size_t strong_sum_len);
_librsync.rs_sig_begin.restype = ctypes.c_void_p
_librsync.rs_sig_begin.argtypes = (ctypes.c_size_t, ctypes.c_size_t, )

# rs_result rs_job_free(rs_job_t *);
_librsync.rs_job_free.restype = ctypes.c_int
_librsync.rs_job_free.argtypes = (ctypes.c_void_p, )

if __name__ == '__main__':
    j = _rsync.rs_sig_begin(1024, 8)
    r = _rsync.rs_job_free(j)
    print('Return code: %s' % r)
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * You need to define the function prototypes you plan to use.
                                        * Assign types to the parameters and return value.
                                        * This code would likely work as-is.
                                        * As soon as you try to use it in a complex program it would likely fail.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Define constants</h3>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <div class="lang"><strong>C (header)</strong></div>
                                                <pre><code class="c" data-trim>
typedef enum {
    RS_DONE =           0,
    RS_BLOCKED =        1,
    ...
} rs_result;

#define RS_DEFAULT_STRONG_LEN 8
#define RS_DEFAULT_BLOCK_LEN 2048
                                                </code></pre>
                                            </div>
                                            <div class="right_col">
                                                <div class="lang"><strong>Python</strong></div>
                                                <pre><code class="python" data-trim>
RS_DONE = 0
RS_BLOCKED = 1

RS_DEFAULT_STRONG_LEN = 8
RS_DEFAULT_BLOCK_LEN = 2048
                                                </code></pre>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Most C libraries will use constants.
                                        * You will need to redefine them in Python.
                                        * You might pass them as parameters, or test return values against them.
                                        </aside>
                                    </section>


                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Define structures</h3>

                                        <div class="wrap">
                                            <div class="left_col">
                                                <div class="lang"><strong>C (header)</strong></div>
                                                <pre><code class="c" data-trim>
struct rs_buffers_s {
    char *next_in;
    size_t avail_in;
    int eof_in;

    char *next_out;
    size_t avail_out;
};
                                                </code></pre>
                                            </div>
                                            <div class="right_col">
                                                <div class="lang"><strong>Python</strong></div>
                                                <pre><code class="python" data-trim>
class Buffer(ctypes.Structure):
    _fields_ = [
        ('next_in',
            ctypes.c_char_p),
        ('avail_in',
            ctypes.c_size_t),
        ('eof_in',
            ctypes.c_int),

        ('next_out',
            ctypes.c_char_p),
        ('avail_out',
            ctypes.c_size_t),
    ]
                                                </code></pre>
                                            </div>
                                        </div>

                                        <aside class="notes" data-markdown>
                                        * Most C libraries will use structures.
                                        * Structs are data types packed together in memory.
                                        * Ctypes allows you to define these as classes.
                                        * You can access the members as attributes.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Define callbacks</h3>

                                        <div class="lang"><strong>C (header)</strong></div>
                                        <pre><code class="c" data-trim>
typedef rs_result rs_copy_cb(void *opaque, rs_long_t pos,
                             size_t *len, void **buf);
                                        </code></pre>

                                        <div class="lang"><strong>Python</strong></div>
                                        <pre><code class="python" data-trim>
callback = ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int, ctypes.c_size_t,
                            ctypes.POINTER(Buffer))
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * Some C libraries use callbacks.
                                        * You pass a pointer to a function and the library calls it.
                                        * Callbacks are commonly used as error handlers, events, I/O.
                                        * Ctypes allows you to create a decorator that declares your callback function prototype.
                                        * You can then decorate a Python function with it.
                                        * You can pass that function to a C library.
                                        * The C library can then make calls into your Python function.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Using callbacks</h3>

                                        <div class="lang"><strong>Python</strong></div>
                                        <pre><code class="python" data-trim>
@callback
def read_cb(ignored, pos, length, buff):
    f.seek(pos)
    block = f.read(length)
    buff.next_in = ctypes.c_char_p(block)
    buff.avail_in = ctypes.c_size_t(len(block))
    return RS_DONE

# Second parameter is a state value to pass to our function, which
# is not used.
job = _librsync.rs_patch_begin(read_cb, None)
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * Decorate the Python function using the `CFUNCTYPE` decorator.
                                        * Pass it to the library as prescribed.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Handling Errors</h3>

                                        <div class="lang"><strong>Python</strong></div>
                                        <pre><code class="python" data-trim>
class LibrsyncError(Exception):
    def __init__(self, r):
        super(LibrsyncError, self).__init__(
              _librsync.rs_strerror(ctypes.c_int(r)))

r = _librsync.rs_job_iter(job, ctypes.byref(buff))
if r not in (RS_DONE, RS_BLOCKED):
    raise LibrsyncError(r)
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * Errors are generally denoted by return values.
                                        * 0 is (almost) universally success.
                                        * Most libraries can convert a return code to an error message.
                                        * Lends itself well to converting return codes to Python Exceptions.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Freeing memory</h3>
                                        <pre><code class="python" data-trim>
sig = ctypes.c_void_p()
try:
    job = _librsync.rs_loadsig_begin(byref(sig))
    try:
        _execute(job, s)
    finally:
        _librsync.rs_job_free(job)
    r = _librsync.rs_build_hash_table(sig)
    if r != RS_DONE:
        raise LibrsyncException(r)
    ...
finally:
    _librsync.rs_free_sumset(sig)
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * No GC in C!
                                        * Allocations made by ctypes use reference counting.
                                        * Allocations made by C functions do NOT!
                                        * The code above makes explicit and implicit allocations.
                                        * Explicit
                                            * You must be dilligent about freeing what you allocate.
                                            * In this example, job is allocated implicitly by calling `rs_loadsig_begin()`.
                                            * It must be freed when we are done with it!
                                        * Implicit.
                                            * You must pay attention to allocations made by the library.
                                            * In this example, sig is a pointer we allocate, and pass by reference.
                                            * The libary performs an allocation and fills the pointer to it.
                                            * We must free the allocated structure when it is no longer needed.
                                        * Finally is your friend!
                                        * When an error occurs and you raise an exception, memory must still be freed.
                                        </aside>
                                    </section>

                                    <section>
                                        <h2>Plan your attack</h2>
                                        <h3>Strings and buffers</h3>
                                        <pre><code class="python" data-trim>
o = StringIO()
out = ctypes.create_string_buffer(RS_JOB_BLOCKSIZE)

while True:
    buff, block = Buffer(), f.read(RS_JOB_BLOCKSIZE)
    # provide the data block via input buffer.
    buff.next_in = ctypes.c_char_p(block)
    buff.avail_in = ctypes.c_size_t(len(block))
    buff.eof_in = ctypes.c_int(not block)
    # Set up our buffer for output.
    buff.next_out = ctypes.cast(out, ctypes.c_char_p)
    buff.avail_out = ctypes.c_size_t(RS_JOB_BLOCKSIZE)
    r = _librsync.rs_job_iter(job, ctypes.byref(buff))
    o.write(out.raw[:RS_JOB_BLOCKSIZE - buff.avail_out])
                                        </code></pre>

                                        <aside class="notes" data-markdown>
                                        * In C strings are char arrays.
                                        * They are represented by a pointer to the head.
                                        * You must be aware of their length.
                                        * You usually must inform the C library of the length.
                                        * This is done to avoid overruns.
                                        * Here we use strings in two capacities.
                                        * Input
                                            * The string `block` is handled by getting `c_char_p`, the pointer to the string buffer.
                                        * Output
                                            * `out` is a string buffer, which can be accessed by Python via `raw`.
                                            * `buff.avail_out` informs librsync how large our allocated buffer is.
                                            * Upon return, librsync tells us how much data to expect via `buff.avail_out`.
                                        </aside>
                                    </section>

				</section>

                            </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
